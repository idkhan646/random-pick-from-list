{"message":"type annotations needed","code":{"code":"E0284","explanation":"This error occurs when the compiler is unable to unambiguously infer the\nreturn type of a function or method which is generic on return type, such\nas the `collect` method for `Iterator`s.\n\nFor example:\n\n```compile_fail,E0284\nfn foo() -> Result<bool, ()> {\n    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n    let v: Vec<bool> = results.collect()?;\n    // Do things with v...\n    Ok(true)\n}\n```\n\nHere we have an iterator `results` over `Result<bool, ()>`.\nHence, `results.collect()` can return any type implementing\n`FromIterator<Result<bool, ()>>`. On the other hand, the\n`?` operator can accept any type implementing `Try`.\n\nThe author of this code probably wants `collect()` to return a\n`Result<Vec<bool>, ()>`, but the compiler can't be sure\nthat there isn't another type `T` implementing both `Try` and\n`FromIterator<Result<bool, ()>>` in scope such that\n`T::Ok == Vec<bool>`. Hence, this code is ambiguous and an error\nis returned.\n\nTo resolve this error, use a concrete type for the intermediate expression:\n\n```\nfn foo() -> Result<bool, ()> {\n    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n    let v = {\n        let temp: Result<Vec<bool>, ()> = results.collect();\n        temp?\n    };\n    // Do things with v...\n    Ok(true)\n}\n```\n\nNote that the type of `v` can now be inferred from the type of `temp`.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1926,"byte_end":1933,"line_start":65,"line_end":65,"column_start":72,"column_end":79,"is_primary":true,"text":[{"text":"    let stuff: String = new_contact.into_iter().map(|i| i.to_string()).collect()?;","highlight_start":72,"highlight_end":79}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `<_ as std::ops::Try>::Ok == _`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider specifying the type argument in the method call","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1933,"byte_end":1933,"line_start":65,"line_end":65,"column_start":79,"column_end":79,"is_primary":true,"text":[{"text":"    let stuff: String = new_contact.into_iter().map(|i| i.to_string()).collect()?;","highlight_start":79,"highlight_end":79}],"label":null,"suggested_replacement":"::<B>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0284]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:65:72\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let stuff: String = new_contact.into_iter().map(|i| i.to_string()).collect()?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcannot infer type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: cannot satisfy `<_ as std::ops::Try>::Ok == _`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider specifying the type argument in the method call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let stuff: String = new_contact.into_iter().map(|i| i.to_string()).collect::<B>()?;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0284`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0284`.\u001b[0m\n"}
